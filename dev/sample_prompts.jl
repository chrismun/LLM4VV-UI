{"idx": 1, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of parallel construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test parallel construct. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, parallel construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 251 Parallel Construct\nSummary\nThis fundamental construct starts parallel execution on the current dev ice\nSyntax\nIn C and C++, the syntax of the OpenACC parallel construct is\n#pragma acc parallel [clause-list ]new-line\nstructured block\n\nand in Fortran, the syntax is\n!$acc parallel [clause-list ]\nstructured block\n!$acc end parallel\nor\n!$acc parallel [clause-list ]\nblock construct\n[!$acc end parallel ]\nwhere clause is one of the following:\nasync [(int-expr)]\nwait [(int-expr-list )]\nnum_gangs( int-expr-list )\nnum_workers( int-expr)\nvector_length( int-expr)\ndevice_type( device-type-list )\nif( condition)\nself [(condition)]\nreduction( operator:var-list)\ncopy( var-list)\ncopyin( [readonly: ]var-list)\ncopyout( [zero: ]var-list)\ncreate( [zero: ]var-list)\nno_create( var-list)\npresent( var-list)\ndeviceptr( var-list)\nattach( var-list)\nprivate( var-list)\nfirstprivate( var-list)\ndefault( none | present )\n\nDescription\nWhen the program encounters an accelerator parallel construct, one or more gangs of workers\nare created to execute the accelerator parallel region The number of ga ngs, and the number of\nworkers in each gang and the number of vector lanes per worker remain c onstant for the duration of\nthat parallel region Each gang begins executing the code in the structure d block in gang-redundant\nmode even if there is only a single gang This means that code within the parallel region, but outside\nof a loop construct with gang-level worksharing, will be executed redu ndantly by all gangs\nOne worker in each gang begins executing the code in the structured block of the construct Note:\nUnless there is a loop construct within the parallel region, all gangs will execute all the code within\nthe region redundantly\nIf theasync clause does not appear, there is an implicit barrier at the end of the accele rator parallel\nregion, and the execution of the local thread will not proceed until all gan gs have reached the end\nof the parallel region\nThecopy ,copyin ,copyout ,create ,no_create ,present ,deviceptr , andattach\ndata clauses are described in Section 27 Data Clauses The private andfirstprivate\nclauses are described in Sections 2513 and Sections 2514 The device_type clause is de-\nscribed in Section 24 Device-Speci\ufb01c Clauses Implicitly determined data attribu tes are described\nin Section 262 Restrictions are described in Section 254\n\nTemplate:\n ```c\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:parallel construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n\n    // complete the test here\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}```"}
{"idx": 2, "Instruction": "Write a code in C to verify compiler implementation of the OpenACC specification of serial construct. \n\nMake sure to follow the template of the format provided. Include the provided header file, and any other necessary libraries.\nWrite simple code to test serial construct. Try to isolate that feature while still using it correctly.\nThis code is part of a testsuite that will be ran, so write complete code, don't leave it unfinished.\nThe goal is to return 0 if the target feature, serial construct, is working properly, and not zero otherwise.\nThe context below is from the most recent OpenACC specification, make sure to refer to it to produce up to date code.\nnote: compute construct means one of parallel, serial, or kernels, and features starting with acc, like acc_attach, are runtime routines.\n\nContext: 252 Serial Construct\nSummary\nThis construct de\ufb01nes a region of the program that is to be executed seq uentially on the current\ndevice The behavior of the serial construct is the same as that of the parallel construct\nexcept that it always executes with a single gang of a single worker with a v ector length of one\nNote: Theserial construct may be used to execute sequential code on the current device ,\nwhich removes the need for data movement when the required data is already present on the device\nSyntax\nIn C and C++, the syntax of the OpenACC serial construct is\n#pragma acc serial [clause-list ]new-line\nstructured block\n\nand in Fortran, the syntax is\n!$acc serial [clause-list ]\nstructured block\n!$acc end serial\nor\n!$acc serial [clause-list ]\nblock construct\n[!$acc end serial ]\nwhere clause is as for the parallel construct except that the num_gangs ,num_workers , and\nvector_length clauses are not permitted\n\nTemplate:\n ```c\n#include \"acc_testsuite.h\"\n#ifndef T1\n//T1:serial construct,V:2.7-3.3\nint test1(){\n    int err = 0;\n\n    // complete the test here\n\n    return err;\n}\n#endif\n\nint main(){\n    int failcode = 0;\n    int failed;\n#ifndef T1\n    failed = 0;\n    for (int x = 0; x < NUM_TEST_CALLS; ++x){\n        failed = failed + test1();\n    }\n    if (failed != 0){\n        failcode = failcode + (1 << 0);\n    }\n#endif\n    return failcode;\n}```"}

